这个是一个常见的面试题，但是回答这个问题并不是很简单
总体上表现：
https://segmentfault.com/a/1190000006879700
DNS解析
TCP连接
发送HTTP请求
服务器处理请求并返回HTTP报文
浏览器解析渲染页面
连接结束
在你的chrome浏览器中输入:chrome://dns/，你可以看到chrome浏览器的DNS缓存。
系统dns本地可以缓存，查看本地缓存
ipconfig /displaydns > e:\d.text
Windows IP 配置

    69.33.90.10.in-addr.arpa
    ----------------------------------------
    记录名称. . . . . . . : 69.33.90.10.in-addr.arpa.
    记录类型. . . . . . . : 12
    生存时间. . . . . . . : 86400
    数据长度. . . . . . . : 8
    部分. . . . . . . . . : 答案
    PTR 记录  . . . . . . : AGENT87
    
    清除本地dns，需要启动进入服务管理窗口。启动“DNS Client”服务后
    ipconfig /flushdns
    添加本地dns
    可以修改host
    
    但是假如当前域名对应放服务放在多台服务器上dns对应一个ip好像不够用吧，这样就有DNS负载均衡，又叫做DNS重定向。大家耳熟能详的CDN(Content Delivery Network)就是利用DNS的重定向技术，
    
    结合profermence可以看到其实在dns之前还有浏览缓存，有个问题是fiddler这类软件是在哪个环节拦截的，还有浏览器的代理服务器又应该如何理解
    
    TCP连接
    TCP协议对应于传输层，而HTTP协议对应于应用层，为什么Http是无状态的短连接，而TCP是有状态的长连接？Http不是建立在TCP的基础上吗，为什么还能是短连接？
    ，Http就是在每次请求完成后就把TCP连接关了，所以是短连接。
    从HTTP/1.1起，默认都开启了Keep-Alive，Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。
    而我们直接通过Socket编程使用TCP协议的时候，因为我们自己可以通过代码区控制什么时候打开连接什么时候关闭连接，只要我们不通过代码把连接关闭，这个连接就会在客户端和服务端的进程中一直存在，相关状态数据会一直保存着。
    Http协议一定通过指定的端口，80，所以一般计算机上不会限制这个端口，所以Http协议能够顺利通过所有机器上的防火墙。
    而使用Socket编程的话，就需要自己指定特定的端口，那么很可能这个端口是在某个环境中禁用的，那么就无法穿透防火墙。
    
    网络层有不同的协议，如IP与ICMP，两者的不同就是对于上层传过来的数据根据什么样的格式进行切割，然后再次封装时候遵循的准则不同。ICMP是Ping命令经常用到的协议。
    利用ICMP回显请求和回显应答报文，而不用经过传输层TCP/UDP。Ping服务器一般在内核中实现ICMP的功能。
    个人感觉操作系统以及网卡是这样工作的，所有的网络数据都是从一个入口进来的，进来之后操作系统与网卡相关的部件就开始从最底层开始解析这些二进制的数据包，一层层的拆包，组装，然后分析，直到IP层的时候，会对IP数据包进行分析，然后进行TCP层的分析，这时候就发现了端口号这个概念，那么会根据端口号的不同，把这些数据存储在不同的缓冲区域，每个缓冲区域属于一个指定的应用程序（以端口号作为标识）。最终应用程序会从自己的缓冲区域来进行网络数据的读取。
    
    关于TCP的通信机制。

 

当TCP发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。TCP将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP将丢弃这个报文段和不确认收到此报文段（希望发端超时并重发）。既然TCP报文段作为IP数据报来传输，而IP数据报的到达可能会失序，因此TCP报文段的到达也可能会失序。如果必要， TCP将对收到的数据进行重新排序，将收到的数据以正确的顺序交给应用层。

  

另外，TCP对字节流的内容不作任何解释

端口号，不是说一个真正存在的实体，或者说在网卡上有个端口啥的。其实端口号就是一个简单的数字标识，用于区分不同的应用程序，有点类似于应用程序的ID，因为网络数据到达了一个主机上边，怎么知道这个数据是给哪个应用程序的呢，这时候端口号就起作用了。前面已经指出过， TCP和UDP采用16bit的端口号来识别应用程序。那么这些端口号是如何选择的呢？服务器一般都是通过知名端口号来识别的。例如，对于每个TCP/IP实现来说，FTP服务器的TCP端口号都是2 1，每个Telnet服务器的TCP端口号都是2 3，每个TFTP (简单文件传送)服务器的UDP端口号都是69。
网络层IP提供的是一种不可靠的服务。也就是说，它只是尽可能快地把分组从源结点送到目的结点，但是并不提供任何可靠性保证。而另一方面， TCP在不可靠的IP层上提供了一个可靠的运输层。为了提供这种可靠的服务， TCP采用了超时重传、发送和接收端到端的确认分组等机制。
IP层的下一层是数据链路层，ARP为IP地址到对应的硬件地址之间提供动态映射

以前有个疑问，就是总觉得进行TCP通信的A与B之间有个管道。如果A在发消息的时候，B也发送消息，那么内容在管道之中不就冲突了么。但是这种想法是错误的。A与B之间根本没有管道，是通过IP层这种路由方式来进行数据包的转换的，发送方与接收方根本都没有指定的路线。发送与接收都是在不同的缓冲区，一般发消息的一方会在发送的内容中添加一个标识符，告诉接收方这次这一批的数据发送完了，你去处理吧，处理完了给我个回复。
还是那句话，建立TCP通道，其实根本没有通道，走的是IP路由，建立通道主要是在电脑内存上开辟出相应的空间。TCP连接一直存在，说明那块相应的缓存区域一直没有被回收。
A与B之间是怎么建立起TCP连接的？

这个就涉及到了3次握手机制。因为B机器上有程序在时刻监视着所有的IP数据包，一旦检测到数据包中含有3次握手的内容，便会打开一个连接，然后通过身份验证等机制，最终建立起TCP连接。
    
    HTTPS过程
HTTPS在传输数据之前需要客户端与服务器进行一个握手(TLS/SSL握手)，在握手过程中将确立双方加密传输数据的密码信息。TLS/SSL使用了非对称加密，对称加密以及hash等。具体过程请参考经典的阮一峰先生的博客TLS/SSL握手过程。
HTTPS相比于HTTP，虽然提供了安全保证，但是势必会带来一些时间上的损耗，如握手和加密等过程，是否使用HTTPS需要根据具体情况在安全和性能方面做出权衡。

